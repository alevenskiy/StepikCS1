#pragma once

/*2.2.8
Напишите рекурсивную функцию вычисления наибольшего общего делителя двух положительных целых чисел
Требования к реализации: в данном задании запрещено пользоваться циклами*/
unsigned gcd(unsigned, unsigned);

/*2.2.10
Вам требуется написать программу, которая "переворачивает" последовательность положительных целых чисел.
На вход подается последовательность разделенных пробелами положительных целых чисел.
Последовательность заканчивается нулем.
Требуется вывести эту последовательность в обратном порядке.
Требования к реализации: в данном задании запрещено использовать циклы, а также дополнительную память: массивы, строки или контейнеры (даже, если вы с ними уже знакомы)*/
void meow();

/*2.3.9
В этой задаче вам нужно реализовать функцию, которая сдвигает содержимое массива влево на заданное число позиций (циклический сдвиг).
На вход функция принимает массив, его размер и величину сдвига.
Например, если на вход функции подан массив: int a[] = { 1, 2, 3, 4, 5 }; и требуется циклически сдвинуть его влево на 2 позиции, то на выходе мы получим числа в таком порядке: 3, 4, 5, 1, 2.
Обратите внимание, что величина сдвига может быть нулевой, а может быть и больше размера массива, все эти случаи нужно учесть.
Требования к реализации: вам нужно реализовать только функцию циклического сдвига.*/
void myrotate(int[], unsigned, int);

/*2.4.6
Напишите функцию, которая вычисляет длину C-style строки*/
unsigned mystrlen(const char*);

/*2.4.7
Вам требуется реализовать функцию конкатенации (склейки) двух C-style строк*/
void mystrcat(char*, const char*);

/*2.4.8
Напишите функцию поиска первого вхождения шаблона в текст*/
int mystrstr(const char*, const char*);

/*2.6.9
В этой задаче вам нужно реализовать функцию resize. 
Функция resize принимает на вход три аргумента: 
	указатель на область памяти, выделенную с помощью оператора new[], 
	размер области (size),
	новый размер (new_size). 
Функция должна выделить память размера new_size, 
	скопировать в нее данные из переданной области памяти, 
	освободить старую область памяти, 
	вернуть выделенную область памяти нового размера со скопированными данными.*/
char* myresize(const char*, unsigned, unsigned);

/*2.6.10 
Реализуйте функцию getline, которая считывает поток ввода посимвольно, 
пока не достигнет конца потока или не встретит символ переноса строки ('\n'), и 
возвращает C-style строку с прочитанными символами
*/
char* mygetline();

/*2.7.9
Напишите функцию, которая принимает на вход целочисленную матрицу M размера rows × cols,
	и возвращает транспонированную матрицу M^T размера cols × rows. 
Если в M на пересечении i-ой строки и j-ого столбца стояло число x, 
	то на пересечении j-ой строки и i-ого столбца в матрице M^T тоже будет стоять число x, 
	или другими словами M^T[j][i] = M[i][j].
Обратите внимание, что вам неизвестно, каким именно способом выделялась память для массива M.
Выделять память под массив M^T можете любым удобным вам способом. 
Изменять исходную матрицу нельзя
*/
int** transpose(const int* const*, unsigned, unsigned);

/*2.7.10
Реализуйте функцию swap_min, которая принимает на вход двумерный массив целых чисел, 
	ищет в этом массиве строку, содержащую наименьшее среди всех элементов массива значение,
	и меняет эту строку местами с первой строкой массива.
*/
void swap_min(int*[], unsigned, unsigned);

